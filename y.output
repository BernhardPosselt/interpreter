Terminals unused in grammar

   T_EQUAL
   T_BINARY_OR
   T_BINARY_AND


State 2 conflicts: 1 shift/reduce
State 15 conflicts: 7 shift/reduce
State 17 conflicts: 1 shift/reduce
State 37 conflicts: 7 shift/reduce
State 48 conflicts: 8 shift/reduce
State 54 conflicts: 7 shift/reduce
State 55 conflicts: 7 shift/reduce


Grammar

    0 $accept: stmt $end

    1 stmt: %empty
    2     | T_LOOP stmt T_FOR expr
    3     | T_LOOP T_FOR expr stmt
    4     | stmt expr T_SEMICOLON
    5     | T_BEGIN stmt T_END
    6     | T_IF expr T_THEN stmt
    7     | T_SUB T_IDENTIFIER T_OPEN_BRACKET arguments T_CLOSE_BRACKET stmt
    8     | T_IF expr T_THEN stmt T_ELSE stmt

    9 number: T_INTEGER
   10       | T_FLOAT

   11 arguments: %empty
   12          | T_IDENTIFIER
   13          | T_IDENTIFIER T_COMMA arguments

   14 expr: T_VAR T_IDENTIFIER T_ASSIGN expr
   15     | number
   16     | number T_PLUS number
   17     | number T_MINUS number
   18     | number T_MULTIPLY number
   19     | number T_DIVIDE number
   20     | number T_MODULO number
   21     | T_MINUS expr
   22     | T_OPEN_BRACKET expr T_CLOSE_BRACKET
   23     | T_NOT expr
   24     | T_RETURN expr
   25     | T_RETURN


Terminals, with rules where they appear

$end (0) 0
error (256)
T_INTEGER (258) 9
T_FLOAT (259) 10
T_VAR (260) 14
T_IDENTIFIER (261) 7 12 13 14
T_SEMICOLON (262) 4
T_EQUAL (263)
T_BEGIN (264) 5
T_END (265) 5
T_LOOP (266) 2 3
T_FOR (267) 2 3
T_SUB (268) 7
T_IF (269) 6 8
T_THEN (270) 6 8
T_ELSE (271) 8
T_ASSIGN (272) 14
T_PLUS (273) 16
T_MINUS (274) 17 21
T_DIVIDE (275) 19
T_MULTIPLY (276) 18
T_MODULO (277) 20
T_NOT (278) 23
T_COMMA (279) 13
T_RETURN (280) 24 25
T_BINARY_OR (281)
T_BINARY_AND (282)
T_OPEN_BRACKET (283) 7 22
T_CLOSE_BRACKET (284) 7 22
T_UNARY_MINUS (285)


Nonterminals, with rules where they appear

$accept (31)
    on left: 0
stmt (32)
    on left: 1 2 3 4 5 6 7 8, on right: 0 2 3 4 5 6 7 8
number (33)
    on left: 9 10, on right: 15 16 17 18 19 20
arguments (34)
    on left: 11 12 13, on right: 7 13
expr (35)
    on left: 14 15 16 17 18 19 20 21 22 23 24 25, on right: 2 3 4 6
    8 14 21 22 23 24


State 0

    0 $accept: . stmt $end

    T_BEGIN  shift, and go to state 1
    T_LOOP   shift, and go to state 2
    T_SUB    shift, and go to state 3
    T_IF     shift, and go to state 4

    $default  reduce using rule 1 (stmt)

    stmt  go to state 5


State 1

    5 stmt: T_BEGIN . stmt T_END

    T_BEGIN  shift, and go to state 1
    T_LOOP   shift, and go to state 2
    T_SUB    shift, and go to state 3
    T_IF     shift, and go to state 4

    $default  reduce using rule 1 (stmt)

    stmt  go to state 6


State 2

    2 stmt: T_LOOP . stmt T_FOR expr
    3     | T_LOOP . T_FOR expr stmt

    T_BEGIN  shift, and go to state 1
    T_LOOP   shift, and go to state 2
    T_FOR    shift, and go to state 7
    T_SUB    shift, and go to state 3
    T_IF     shift, and go to state 4

    T_FOR     [reduce using rule 1 (stmt)]
    $default  reduce using rule 1 (stmt)

    stmt  go to state 8


State 3

    7 stmt: T_SUB . T_IDENTIFIER T_OPEN_BRACKET arguments T_CLOSE_BRACKET stmt

    T_IDENTIFIER  shift, and go to state 9


State 4

    6 stmt: T_IF . expr T_THEN stmt
    8     | T_IF . expr T_THEN stmt T_ELSE stmt

    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    number  go to state 17
    expr    go to state 18


State 5

    0 $accept: stmt . $end
    4 stmt: stmt . expr T_SEMICOLON

    $end            shift, and go to state 19
    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    number  go to state 17
    expr    go to state 20


State 6

    4 stmt: stmt . expr T_SEMICOLON
    5     | T_BEGIN stmt . T_END

    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_END           shift, and go to state 21
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    number  go to state 17
    expr    go to state 20


State 7

    3 stmt: T_LOOP T_FOR . expr stmt

    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    number  go to state 17
    expr    go to state 22


State 8

    2 stmt: T_LOOP stmt . T_FOR expr
    4     | stmt . expr T_SEMICOLON

    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_FOR           shift, and go to state 23
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    number  go to state 17
    expr    go to state 20


State 9

    7 stmt: T_SUB T_IDENTIFIER . T_OPEN_BRACKET arguments T_CLOSE_BRACKET stmt

    T_OPEN_BRACKET  shift, and go to state 24


State 10

    9 number: T_INTEGER .

    $default  reduce using rule 9 (number)


State 11

   10 number: T_FLOAT .

    $default  reduce using rule 10 (number)


State 12

   14 expr: T_VAR . T_IDENTIFIER T_ASSIGN expr

    T_IDENTIFIER  shift, and go to state 25


State 13

   21 expr: T_MINUS . expr

    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    number  go to state 17
    expr    go to state 26


State 14

   23 expr: T_NOT . expr

    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    number  go to state 17
    expr    go to state 27


State 15

   24 expr: T_RETURN . expr
   25     | T_RETURN .

    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    T_INTEGER       [reduce using rule 25 (expr)]
    T_FLOAT         [reduce using rule 25 (expr)]
    T_VAR           [reduce using rule 25 (expr)]
    T_MINUS         [reduce using rule 25 (expr)]
    T_NOT           [reduce using rule 25 (expr)]
    T_RETURN        [reduce using rule 25 (expr)]
    T_OPEN_BRACKET  [reduce using rule 25 (expr)]
    $default        reduce using rule 25 (expr)

    number  go to state 17
    expr    go to state 28


State 16

   22 expr: T_OPEN_BRACKET . expr T_CLOSE_BRACKET

    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    number  go to state 17
    expr    go to state 29


State 17

   15 expr: number .
   16     | number . T_PLUS number
   17     | number . T_MINUS number
   18     | number . T_MULTIPLY number
   19     | number . T_DIVIDE number
   20     | number . T_MODULO number

    T_PLUS      shift, and go to state 30
    T_MINUS     shift, and go to state 31
    T_DIVIDE    shift, and go to state 32
    T_MULTIPLY  shift, and go to state 33
    T_MODULO    shift, and go to state 34

    T_MINUS   [reduce using rule 15 (expr)]
    $default  reduce using rule 15 (expr)


State 18

    6 stmt: T_IF expr . T_THEN stmt
    8     | T_IF expr . T_THEN stmt T_ELSE stmt

    T_THEN  shift, and go to state 35


State 19

    0 $accept: stmt $end .

    $default  accept


State 20

    4 stmt: stmt expr . T_SEMICOLON

    T_SEMICOLON  shift, and go to state 36


State 21

    5 stmt: T_BEGIN stmt T_END .

    $default  reduce using rule 5 (stmt)


State 22

    3 stmt: T_LOOP T_FOR expr . stmt

    T_BEGIN  shift, and go to state 1
    T_LOOP   shift, and go to state 2
    T_SUB    shift, and go to state 3
    T_IF     shift, and go to state 4

    $default  reduce using rule 1 (stmt)

    stmt  go to state 37


State 23

    2 stmt: T_LOOP stmt T_FOR . expr

    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    number  go to state 17
    expr    go to state 38


State 24

    7 stmt: T_SUB T_IDENTIFIER T_OPEN_BRACKET . arguments T_CLOSE_BRACKET stmt

    T_IDENTIFIER  shift, and go to state 39

    $default  reduce using rule 11 (arguments)

    arguments  go to state 40


State 25

   14 expr: T_VAR T_IDENTIFIER . T_ASSIGN expr

    T_ASSIGN  shift, and go to state 41


State 26

   21 expr: T_MINUS expr .

    $default  reduce using rule 21 (expr)


State 27

   23 expr: T_NOT expr .

    $default  reduce using rule 23 (expr)


State 28

   24 expr: T_RETURN expr .

    $default  reduce using rule 24 (expr)


State 29

   22 expr: T_OPEN_BRACKET expr . T_CLOSE_BRACKET

    T_CLOSE_BRACKET  shift, and go to state 42


State 30

   16 expr: number T_PLUS . number

    T_INTEGER  shift, and go to state 10
    T_FLOAT    shift, and go to state 11

    number  go to state 43


State 31

   17 expr: number T_MINUS . number

    T_INTEGER  shift, and go to state 10
    T_FLOAT    shift, and go to state 11

    number  go to state 44


State 32

   19 expr: number T_DIVIDE . number

    T_INTEGER  shift, and go to state 10
    T_FLOAT    shift, and go to state 11

    number  go to state 45


State 33

   18 expr: number T_MULTIPLY . number

    T_INTEGER  shift, and go to state 10
    T_FLOAT    shift, and go to state 11

    number  go to state 46


State 34

   20 expr: number T_MODULO . number

    T_INTEGER  shift, and go to state 10
    T_FLOAT    shift, and go to state 11

    number  go to state 47


State 35

    6 stmt: T_IF expr T_THEN . stmt
    8     | T_IF expr T_THEN . stmt T_ELSE stmt

    T_BEGIN  shift, and go to state 1
    T_LOOP   shift, and go to state 2
    T_SUB    shift, and go to state 3
    T_IF     shift, and go to state 4

    $default  reduce using rule 1 (stmt)

    stmt  go to state 48


State 36

    4 stmt: stmt expr T_SEMICOLON .

    $default  reduce using rule 4 (stmt)


State 37

    3 stmt: T_LOOP T_FOR expr stmt .
    4     | stmt . expr T_SEMICOLON

    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    T_INTEGER       [reduce using rule 3 (stmt)]
    T_FLOAT         [reduce using rule 3 (stmt)]
    T_VAR           [reduce using rule 3 (stmt)]
    T_MINUS         [reduce using rule 3 (stmt)]
    T_NOT           [reduce using rule 3 (stmt)]
    T_RETURN        [reduce using rule 3 (stmt)]
    T_OPEN_BRACKET  [reduce using rule 3 (stmt)]
    $default        reduce using rule 3 (stmt)

    number  go to state 17
    expr    go to state 20


State 38

    2 stmt: T_LOOP stmt T_FOR expr .

    $default  reduce using rule 2 (stmt)


State 39

   12 arguments: T_IDENTIFIER .
   13          | T_IDENTIFIER . T_COMMA arguments

    T_COMMA  shift, and go to state 49

    $default  reduce using rule 12 (arguments)


State 40

    7 stmt: T_SUB T_IDENTIFIER T_OPEN_BRACKET arguments . T_CLOSE_BRACKET stmt

    T_CLOSE_BRACKET  shift, and go to state 50


State 41

   14 expr: T_VAR T_IDENTIFIER T_ASSIGN . expr

    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    number  go to state 17
    expr    go to state 51


State 42

   22 expr: T_OPEN_BRACKET expr T_CLOSE_BRACKET .

    $default  reduce using rule 22 (expr)


State 43

   16 expr: number T_PLUS number .

    $default  reduce using rule 16 (expr)


State 44

   17 expr: number T_MINUS number .

    $default  reduce using rule 17 (expr)


State 45

   19 expr: number T_DIVIDE number .

    $default  reduce using rule 19 (expr)


State 46

   18 expr: number T_MULTIPLY number .

    $default  reduce using rule 18 (expr)


State 47

   20 expr: number T_MODULO number .

    $default  reduce using rule 20 (expr)


State 48

    4 stmt: stmt . expr T_SEMICOLON
    6     | T_IF expr T_THEN stmt .
    8     | T_IF expr T_THEN stmt . T_ELSE stmt

    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_ELSE          shift, and go to state 52
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    T_INTEGER       [reduce using rule 6 (stmt)]
    T_FLOAT         [reduce using rule 6 (stmt)]
    T_VAR           [reduce using rule 6 (stmt)]
    T_ELSE          [reduce using rule 6 (stmt)]
    T_MINUS         [reduce using rule 6 (stmt)]
    T_NOT           [reduce using rule 6 (stmt)]
    T_RETURN        [reduce using rule 6 (stmt)]
    T_OPEN_BRACKET  [reduce using rule 6 (stmt)]
    $default        reduce using rule 6 (stmt)

    number  go to state 17
    expr    go to state 20


State 49

   13 arguments: T_IDENTIFIER T_COMMA . arguments

    T_IDENTIFIER  shift, and go to state 39

    $default  reduce using rule 11 (arguments)

    arguments  go to state 53


State 50

    7 stmt: T_SUB T_IDENTIFIER T_OPEN_BRACKET arguments T_CLOSE_BRACKET . stmt

    T_BEGIN  shift, and go to state 1
    T_LOOP   shift, and go to state 2
    T_SUB    shift, and go to state 3
    T_IF     shift, and go to state 4

    $default  reduce using rule 1 (stmt)

    stmt  go to state 54


State 51

   14 expr: T_VAR T_IDENTIFIER T_ASSIGN expr .

    $default  reduce using rule 14 (expr)


State 52

    8 stmt: T_IF expr T_THEN stmt T_ELSE . stmt

    T_BEGIN  shift, and go to state 1
    T_LOOP   shift, and go to state 2
    T_SUB    shift, and go to state 3
    T_IF     shift, and go to state 4

    $default  reduce using rule 1 (stmt)

    stmt  go to state 55


State 53

   13 arguments: T_IDENTIFIER T_COMMA arguments .

    $default  reduce using rule 13 (arguments)


State 54

    4 stmt: stmt . expr T_SEMICOLON
    7     | T_SUB T_IDENTIFIER T_OPEN_BRACKET arguments T_CLOSE_BRACKET stmt .

    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    T_INTEGER       [reduce using rule 7 (stmt)]
    T_FLOAT         [reduce using rule 7 (stmt)]
    T_VAR           [reduce using rule 7 (stmt)]
    T_MINUS         [reduce using rule 7 (stmt)]
    T_NOT           [reduce using rule 7 (stmt)]
    T_RETURN        [reduce using rule 7 (stmt)]
    T_OPEN_BRACKET  [reduce using rule 7 (stmt)]
    $default        reduce using rule 7 (stmt)

    number  go to state 17
    expr    go to state 20


State 55

    4 stmt: stmt . expr T_SEMICOLON
    8     | T_IF expr T_THEN stmt T_ELSE stmt .

    T_INTEGER       shift, and go to state 10
    T_FLOAT         shift, and go to state 11
    T_VAR           shift, and go to state 12
    T_MINUS         shift, and go to state 13
    T_NOT           shift, and go to state 14
    T_RETURN        shift, and go to state 15
    T_OPEN_BRACKET  shift, and go to state 16

    T_INTEGER       [reduce using rule 8 (stmt)]
    T_FLOAT         [reduce using rule 8 (stmt)]
    T_VAR           [reduce using rule 8 (stmt)]
    T_MINUS         [reduce using rule 8 (stmt)]
    T_NOT           [reduce using rule 8 (stmt)]
    T_RETURN        [reduce using rule 8 (stmt)]
    T_OPEN_BRACKET  [reduce using rule 8 (stmt)]
    $default        reduce using rule 8 (stmt)

    number  go to state 17
    expr    go to state 20
